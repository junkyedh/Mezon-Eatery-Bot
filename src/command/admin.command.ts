import { ChannelMessage } from 'mezon-sdk';
import { Command } from '@app/decorators/command.decorator';
import { CommandMessage } from '@app/command/common/command.abstract';
import { PoolService } from '@app/services/pool.service';
import { MezonWalletService } from '@app/services/mezon-wallet.service';
import { LoanService } from '@app/services/loan.service';
import { formatToken } from '@app/utils/token-format';
import { UserService } from '@app/services/user.service';

// Admin list: configure via env ADMIN_MZ_USERS (comma-separated mezonUserIds)
function getAdminIds(): string[] {
  const raw = process.env.ADMIN_MZ_USERS || '';
  return raw
    .split(',')
    .map((s) => s.trim())
    .filter((s) => s.length > 0);
}

const runtimeAdminIds = new Set<string>();
const runtimeAdminUsernames = new Set<string>();

function isOwner(mezonUserId: string): boolean {
  const admins = getAdminIds();
  return admins.includes(mezonUserId);
}

function isAdmin(mezonUserId: string, username?: string): boolean {
  if (isOwner(mezonUserId)) return true;
  if (runtimeAdminIds.has(mezonUserId)) return true;
  if (username && runtimeAdminUsernames.has(username.toLowerCase()))
    return true;
  return false;
}

@Command('admin', {
  description: 'Admin commands for pool management',
  usage: '!admin [balance|withdraw|assign]...',
  category: 'Admin',
  aliases: ['adm'],
})
export class AdminCommand extends CommandMessage {
  constructor(
    private poolService: PoolService,
    private mezonWalletService: MezonWalletService,
    private userService: UserService,
    private loanService: LoanService,
  ) {
    super();
  }

  async execute(args: string[], message: ChannelMessage) {
    if (!isAdmin(message.sender_id, message.username)) {
      const messageContent = '‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán l·ªánh n√†y.';
      return this.replyMessageGenerate({ messageContent }, message);
    }

    const subCommand = args[0]?.toLowerCase();

    switch (subCommand) {
      case 'balance':
        return this.showPoolBalance(message);
      case 'withdraw':
        return this.withdrawFromPool(args.slice(1), message);
      case 'debug-fees':
        if (!isOwner(message.sender_id)) {
          const messageContent = '‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn debug fees.';
          return this.replyMessageGenerate({ messageContent }, message);
        }
        return this.debugFees(message);
      case 'reset-pool':
        if (!isOwner(message.sender_id)) {
          const messageContent = '‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn reset pool.';
          return this.replyMessageGenerate({ messageContent }, message);
        }
        return this.resetPool(message);
      case 'reset-loan':
        if (!isOwner(message.sender_id)) {
          const messageContent = '‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn reset loan.';
          return this.replyMessageGenerate({ messageContent }, message);
        }
        return this.resetLoan(args.slice(1), message);
      case 'revoke':
        if (!isOwner(message.sender_id)) {
          const messageContent = '‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn thu h·ªìi admin.';
          return this.replyMessageGenerate({ messageContent }, message);
        }
        return this.revokeAdmin(args.slice(1), message);
      case 'assign':
        if (!isOwner(message.sender_id)) {
          const messageContent = '‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn g√°n admin.';
          return this.replyMessageGenerate({ messageContent }, message);
        }
        return this.assignAdmin(args.slice(1), message);
      default:
        const base = [
          'üìã Admin',
          '‚Ä¢ `!admin balance` - Xem s·ªë d∆∞ pool',
          '‚Ä¢ `!admin withdraw <amount>` - R√∫t ph√≠ t·ª´ pool',
        ];
        if (isOwner(message.sender_id)) {
          base.push('‚Ä¢ `!admin debug-fees` - Debug fee calculation');
          base.push('‚Ä¢ `!admin reset-pool` - T√≠nh l·∫°i pool (debug)');
          base.push(
            '‚Ä¢ `!admin reset-loan <loanId>` - Reset tr·∫°ng th√°i loan (debug)',
          );
          base.push('‚Ä¢ `!admin assign @JunKye|@dhduonghan` - C·∫•p quy·ªÅn t·∫°m');
          base.push(
            '‚Ä¢ `!admin revoke @JunKye|@dhduonghan|all` - Thu h·ªìi quy·ªÅn',
          );
        }
        const helpText = base.join('\n');
        return this.replyMessageGenerate({ messageContent: helpText }, message);
    }
  }

  async showPoolBalance(message: ChannelMessage) {
    try {
      const poolBalance = await this.poolService.getPoolBalance();
      const feesCollected =
        await this.loanService.getTotalFeesFromActiveAndCompletedLoans();

      const users = await this.userService.getUsersWithPositiveBalance();

      const messageLines = [
        'üí∞ **Pool Balance**',
        `‚Ä¢ T·ªïng token trong bot: ${formatToken(poolBalance.total)}`,
        `‚Ä¢ Kh·∫£ d·ª•ng (user balances): ${formatToken(poolBalance.available)}`,
      ];

      if (users.length > 0) {
        for (const user of users) {
          const shortId = user.mezonUserId
            ? user.mezonUserId.substring(0, 8) + '...'
            : 'N/A';
          const username = user.username || 'Unknown';
          messageLines.push(
            `üë§ ${username} (${shortId}): ${formatToken(user.balance)}`,
          );
        }
      } else {
        messageLines.push('üë§ Kh√¥ng c√≥ user n√†o c√≥ balance d∆∞∆°ng');
      }

      messageLines.push(
        `‚Ä¢ ƒêang cho vay: ${formatToken(poolBalance.loaned)}`,
        `‚Ä¢ Ph√≠ giao d·ªãch: ${formatToken(feesCollected)}`,
      );

      const messageContent = messageLines.join('\n');

      return this.replyMessageGenerate({ messageContent }, message);
    } catch (error) {
      const messageContent = `‚ùå L·ªói: ${error.message}`;
      return this.replyMessageGenerate({ messageContent }, message);
    }
  }

  async debugFees(message: ChannelMessage) {
    try {
      const poolBalance = await this.poolService.getPoolBalance();
      const totalFeesFromLoans =
        await this.loanService.getTotalFeesFromActiveAndCompletedLoans();
      const activeLoans = await this.loanService.getActiveLoansAmount();

      const feeFromPool =
        poolBalance.total - (poolBalance.available + poolBalance.loaned);
      const feeFromLoanService = totalFeesFromLoans;

      const messageContent = [
        'üîç **Ph√¢n t√≠ch ph√≠ (Debug)**',
        `‚Ä¢ T·ªïng pool: ${formatToken(poolBalance.total)}`,
        `‚Ä¢ Kh·∫£ d·ª•ng: ${formatToken(poolBalance.available)}`,
        `‚Ä¢ ƒêang cho vay: ${formatToken(poolBalance.loaned)}`,
        `‚Ä¢ T·ªïng kho·∫£n vay ƒëang ho·∫°t ƒë·ªông: ${formatToken(activeLoans)}`,
        '',
        'üìä **T√≠nh ph√≠:**',
        `‚Ä¢ Ph√≠ (theo pool): ${formatToken(Math.max(0, feeFromPool))}`,
        `‚Ä¢ Ph√≠ (theo loan): ${formatToken(feeFromLoanService)}`,
        '',
        'üéØ **C√¥ng th·ª©c:**',
        '‚Ä¢ Ph√≠ pool = t·ªïng - (kh·∫£ d·ª•ng + cho vay)',
        '‚Ä¢ Ph√≠ loan = t·ªïng ph√≠ t·ª´ c√°c kho·∫£n vay',
      ].join('\n');

      return this.replyMessageGenerate({ messageContent }, message);
    } catch (error) {
      const messageContent = `‚ùå Debug fees error: ${error.message}`;
      return this.replyMessageGenerate({ messageContent }, message);
    }
  }

  async withdrawFromPool(args: string[], message: ChannelMessage) {
    if (args.length < 1) {
      const messageContent =
        '‚ùå Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng token mu·ªën r√∫t.\n\n**C√°ch d√πng:** `!admin withdraw <amount>`';
      return this.replyMessageGenerate({ messageContent }, message);
    }

    const amount = parseInt(args[0]);
    if (isNaN(amount) || amount <= 0) {
      const messageContent =
        '‚ùå S·ªë token kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë d∆∞∆°ng.';
      return this.replyMessageGenerate({ messageContent }, message);
    }

    try {
      const poolBalance = await this.poolService.getPoolBalance();
      const rawFees =
        poolBalance.total - (poolBalance.available + poolBalance.loaned);
      const feesCollected = Math.max(0, Math.round(Number(rawFees)));

      if (amount > feesCollected) {
        const messageContent = `‚ùå S·ªë token r√∫t (${formatToken(amount)}) l·ªõn h∆°n ph√≠ hi·ªán c√≥ (${formatToken(feesCollected)}).`;
        return this.replyMessageGenerate({ messageContent }, message);
      }

      const idemKey = `admin_withdraw:${Date.now()}:${message.sender_id}`;

      const walletResult = await this.mezonWalletService.transferBotToUser({
        toUserId: message.sender_id,
        amount,
        idemKey,
      });

      if (!walletResult.success) {
        const messageContent = '‚ùå Giao d·ªãch th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i sau.';
        return this.replyMessageGenerate({ messageContent }, message);
      }

      await this.poolService.withdrawFee(amount);

      const messageContent = [
        '‚úÖ **R√∫t ph√≠ th√†nh c√¥ng**',
        `‚Ä¢ S·ªë l∆∞·ª£ng: ${formatToken(amount)}`,
        `‚Ä¢ Ph√≠ c√≤n l·∫°i: ${formatToken(feesCollected - amount)}`,
      ].join('\n');

      return this.replyMessageGenerate({ messageContent }, message);
    } catch (error) {
      const messageContent = `‚ùå L·ªói: ${error.message}`;
      return this.replyMessageGenerate({ messageContent }, message);
    }
  }

  async assignAdmin(args: string[], message: ChannelMessage) {
    if (args.length < 1) {
      const messageContent =
        '‚ùå C√°ch d√πng: `!admin assign @JunKye` ho·∫∑c `!admin assign @dhduonghan`';
      return this.replyMessageGenerate({ messageContent }, message);
    }
    const raw = args[0].trim();
    const handle = (raw.startsWith('@') ? raw.slice(1) : raw).trim();
    const allowed = ['JunKye', 'dhduonghan'];
    if (!allowed.includes(handle)) {
      const messageContent =
        '‚ùå Hi·ªán ch·ªâ g√°n ƒë∆∞·ª£c cho @JunKye ho·∫∑c @dhduonghan.';
      return this.replyMessageGenerate({ messageContent }, message);
    }

    const handleToUsernames: Record<string, string[]> = {
      JunKye: ['junkye105', 'junkye'],
      dhduonghan: ['dhduonghan', 'han.duonghai'],
    };
    const candidates = handleToUsernames[handle] || [handle];

    let resolved = false;
    for (const uname of candidates) {
      const u = await this.userService.getUserByUsername(uname);
      if (u?.mezonUserId) {
        runtimeAdminIds.add(u.mezonUserId);
        resolved = true;
      }
      runtimeAdminUsernames.add(uname.toLowerCase());
    }

    const messageContent = resolved
      ? `‚úÖ ƒê√£ c·∫•p quy·ªÅn t·∫°m cho @${handle}. C√≥ th·ªÉ d√πng: !admin balance, !admin withdraw.`
      : `‚úÖ ƒê√£ c·∫•p quy·ªÅn t·∫°m cho @${handle}. C√≥ th·ªÉ d√πng: !admin balance, !admin withdraw.`;
    return this.replyMessageGenerate({ messageContent }, message);
  }

  async revokeAdmin(args: string[], message: ChannelMessage) {
    if (args.length < 1) {
      const messageContent =
        '‚ùå C√°ch d√πng: `!admin revoke @JunKye|@dhduonghan|all`';
      return this.replyMessageGenerate({ messageContent }, message);
    }

    const raw = args[0].trim();
    const token = (raw.startsWith('@') ? raw.slice(1) : raw).trim();

    if (token.toLowerCase() === 'all') {
      runtimeAdminIds.clear();
      runtimeAdminUsernames.clear();
      const messageContent = '‚úÖ ƒê√£ thu h·ªìi to√†n b·ªô quy·ªÅn admin t·∫°m.';
      return this.replyMessageGenerate({ messageContent }, message);
    }

    const allowed = ['JunKye', 'dhduonghan'];
    if (!allowed.includes(token)) {
      const messageContent =
        '‚ùå Hi·ªán ch·ªâ thu h·ªìi ƒë∆∞·ª£c c·ªßa @JunKye ho·∫∑c @dhduonghan.';
      return this.replyMessageGenerate({ messageContent }, message);
    }

    const handleToUsernames: Record<string, string[]> = {
      JunKye: ['junkye105', 'junkye'],
      dhduonghan: ['dhduonghan', 'han.duonghai'],
    };
    const candidates = handleToUsernames[token] || [token];

    for (const uname of candidates) {
      runtimeAdminUsernames.delete(uname.toLowerCase());
      const u = await this.userService.getUserByUsername(uname);
      if (u?.mezonUserId) runtimeAdminIds.delete(u.mezonUserId);
    }

    const messageContent = `‚úÖ ƒê√£ thu h·ªìi quy·ªÅn t·∫°m c·ªßa @${token}.`;
    return this.replyMessageGenerate({ messageContent }, message);
  }

  async resetPool(message: ChannelMessage) {
    try {
      await this.poolService.recalculatePool();

      const poolBalance = await this.poolService.getPoolBalance();
      const rawFees =
        poolBalance.total - (poolBalance.available + poolBalance.loaned);
      const feesCollected = Math.max(0, Math.round(Number(rawFees)));

      const messageContent = [
        '‚úÖ **Pool ƒë√£ ƒë∆∞·ª£c t√≠nh l·∫°i**',
        `‚Ä¢ T·ªïng token trong bot: ${formatToken(poolBalance.total)}`,
        `‚Ä¢ Kh·∫£ d·ª•ng (user balances): ${formatToken(poolBalance.available)}`,
        `‚Ä¢ ƒêang cho vay: ${formatToken(poolBalance.loaned)}`,
        `‚Ä¢ Ph√≠ giao d·ªãch: ${formatToken(feesCollected)}`,
      ].join('\n');

      return this.replyMessageGenerate({ messageContent }, message);
    } catch (error) {
      const messageContent = `‚ùå L·ªói khi t√≠nh l·∫°i pool: ${error.message}`;
      return this.replyMessageGenerate({ messageContent }, message);
    }
  }

  async resetLoan(args: string[], message: ChannelMessage) {
    if (args.length < 1) {
      const messageContent =
        '‚ùå Thi·∫øu loanId. C√∫ ph√°p: `!admin reset-loan <loanId>`';
      return this.replyMessageGenerate({ messageContent }, message);
    }

    const loanId = args[0];

    try {
      const loan = await this.loanService.getLoanById(loanId);

      if (!loan) {
        const messageContent = `‚ùå Kh√¥ng t√¨m th·∫•y loan v·ªõi ID: ${loanId}`;
        return this.replyMessageGenerate({ messageContent }, message);
      }

      await this.loanService.resetLoanToActive(loanId);

      await this.poolService.recalculatePool();

      const messageContent = [
        '‚úÖ **Loan ƒë√£ ƒë∆∞·ª£c reset th√†nh c√¥ng**',
        `üÜî Loan ID: ${loanId}`,
        `üìä Tr·∫°ng th√°i: ACTIVE`,
        `üí∞ S·ªë ti·ªÅn: ${formatToken(loan.amount)}`,
        'üîÑ Pool ƒë√£ ƒë∆∞·ª£c t√≠nh l·∫°i',
      ].join('\n');

      return this.replyMessageGenerate({ messageContent }, message);
    } catch (error) {
      const messageContent = `‚ùå L·ªói khi reset loan: ${error.message}`;
      return this.replyMessageGenerate({ messageContent }, message);
    }
  }
}
